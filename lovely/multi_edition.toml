[manifest]
version = "1.0.0"
priority = 30

# G.FUNCS.evaluate_play()
[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''local eval = eval_card(_card, {cardarea = G.jokers, full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands, edition = true, pre_joker = true})
if eval.edition then effects[#effects+1] = eval end'''
position = "at"
payload = '''local pre_joker_context = {cardarea = G.jokers, full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands, edition = true, pre_joker = true}
local eval = eval_card(_card, pre_joker_context)
if eval.edition then effects[#effects+1] = eval end
SMODS.fnwk_calculate_quantum_editions(_card, effects, pre_joker_context)'''
match_indent = true
times = 1

# G.FUNCS.evaluate_play()
[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''local eval = eval_card(_card, {cardarea = G.jokers, full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands, edition = true, post_joker = true})
if eval.edition then effects[#effects+1] = eval end'''
position = "at"
payload = '''local post_joker_context = {cardarea = G.jokers, full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands, edition = true, post_joker = true}
local eval = eval_card(_card, post_joker_context)
if eval.edition then effects[#effects+1] = eval end
SMODS.fnwk_calculate_quantum_editions(_card, effects, post_joker_context)'''
match_indent = true
times = 1

# Card:set_edition()
[[patches]]
[patches.pattern]
target = '=[SMODS _ "src/overrides.lua"]'
pattern = '''function Card:set_edition(edition, immediate, silent, delay)'''
position = "at"
payload = '''function Card:set_edition(edition, immediate, silent, delay, force_ilsa)'''
match_indent = true
times = 1

# Card:set_edition()
[[patches]]
[patches.pattern]
target = '=[SMODS _ "src/overrides.lua"]'
pattern = '''self.edition = {}
self.edition[edition_type] = true
self.edition.type = edition_type
self.edition.key = 'e_' .. edition_type

local p_edition = G.P_CENTERS['e_' .. edition_type]

if p_edition.override_base_shader or p_edition.disable_base_shader then
    self.ignore_base_shader[self.edition.key] = true
end
if p_edition.no_shadow or p_edition.disable_shadow then
    self.ignore_shadow[self.edition.key] = true
end

local on_edition_applied = p_edition.on_apply
if type(on_edition_applied) == "function" then
    on_edition_applied(self)
end

for k, v in pairs(p_edition.config) do
    if type(v) == 'table' then
        self.edition[k] = copy_table(v)
    else
        self.edition[k] = v
    end
    if k == 'card_limit' and (self.added_to_deck or self.joker_added_to_deck_but_debuffed or (self.area == G.hand and not self.debuff)) and G.jokers and G.consumeables then
        if self.ability.consumeable then
            G.consumeables.config.card_limit = G.consumeables.config.card_limit + v
        elseif self.ability.set == 'Joker' then
            G.jokers.config.card_limit = G.jokers.config.card_limit + v
        elseif self.area == G.hand then
            local is_in_pack = (G.STATE == G.STATES.TAROT_PACK or G.STATE == G.STATES.SPECTRAL_PACK or (G.STATE == G.STATES.SMODS_BOOSTER_OPENED and SMODS.OPENED_BOOSTER.config.center.draw_hand))
            G.E_MANAGER:add_event(Event({
                trigger = 'immediate',
                func = function()
                    if G.hand.config.real_card_limit then
                        G.hand.config.real_card_limit = G.hand.config.real_card_limit + v
                    end
                    G.hand.config.card_limit = G.hand.config.card_limit + v
                    if not is_in_pack and G.GAME.blind.in_blind then
                        G.FUNCS.draw_from_deck_to_hand(v)
                    end
                    return true
                end
            }))
        end
    end
end'''
position = "at"
payload = '''self.edition = {}
self.edition.others = {}
local all_types = {[edition_type] = true}
if force_ilsa or next(SMODS.find_card('j_fnwk_jspec_ilsa')) then
    all_types['holo'] = true
    all_types['foil'] = true
    all_types['polychrome'] = true
end

for k, v in pairs(all_types) do
    local get_edition = G.P_CENTERS['e_' .. k]
    local edition_table = {}
    for k, v in pairs(get_edition.config) do
        if type(v) == 'table' then
            edition_table[k] = copy_table(v)
        else
            edition_table[k] = v
        end
        if k == 'card_limit' and (self.added_to_deck or self.joker_added_to_deck_but_debuffed or (self.area == G.hand and not self.debuff)) and G.jokers and G.consumeables then
            if self.ability.consumeable then
                G.consumeables.config.card_limit = G.consumeables.config.card_limit + v
            elseif self.ability.set == 'Joker' then
                G.jokers.config.card_limit = G.jokers.config.card_limit + v
            elseif self.area == G.hand then
                local is_in_pack = (G.STATE == G.STATES.TAROT_PACK or G.STATE == G.STATES.SPECTRAL_PACK or (G.STATE == G.STATES.SMODS_BOOSTER_OPENED and SMODS.OPENED_BOOSTER.config.center.draw_hand))
                G.E_MANAGER:add_event(Event({
                    trigger = 'immediate',
                    func = function()
                        if G.hand.config.real_card_limit then
                            G.hand.config.real_card_limit = G.hand.config.real_card_limit + v
                        end
                        G.hand.config.card_limit = G.hand.config.card_limit + v
                        if not is_in_pack and G.GAME.blind.in_blind then
                            G.FUNCS.draw_from_deck_to_hand(v)
                        end
                        return true
                    end
                }))
            end
        end
    end

    if k == edition_type then
        self.edition[k] = true
        self.edition.type = k
        local key = 'e_' .. k
        self.edition.key = key
        if get_edition.override_base_shader or get_edition.disable_base_shader then
            self.ignore_base_shader[key] = true
        end
        if get_edition.no_shadow or get_edition.disable_shadow then
            self.ignore_shadow[key] = true
        end
        for k, v in pairs(edition_table) do
            self.edition[k] = v
        end
    else 
        local other_edition = {
            [k] = true,
            type = k,
            key = 'e_' .. k
        }
        for k, v in pairs(edition_table) do
            other_edition[k] = v
        end
        self.edition.others[#self.edition.others+1] = other_edition
    end

    local on_edition_applied = get_edition.on_apply
    if type(on_edition_applied) == "function" then
        on_edition_applied(self)
    end
end
if next(self.edition.others) == nil then
    self.edition.others = nil
end'''
match_indent = true
times = 1

# SMODS.calculate_context()
[[patches]]
[patches.pattern]
target = '=[SMODS _ "src/utils.lua"]'
pattern = '''SMODS.calculate_quantum_enhancements(card, quantum_eval, context)'''
position = "after"
payload = '''SMODS.fnwk_calculate_quantum_editions(card, quantum_eval, context)'''
match_indent = true
times = 1

# SMODS.calculate_context()
[[patches]]
[patches.pattern]
target = '=[SMODS _ "src/utils.lua"]'
pattern = '''SMODS.calculate_quantum_enhancements(card, effects, context)'''
position = "after"
payload = '''SMODS.fnwk_calculate_quantum_editions(card, effects, context)'''
match_indent = true
times = 3